# ch8 C++异常处理（try catch）从入门到精通
程序运行过程中会碰到一些错误，如除数为0，年龄为负数，数组下标越界，这些错误如果不能提早判断并加以处理，会导致程序崩溃。
C++ 异常处理机制就可以让我们捕获并处理这些错误，然后我们可以让程序沿着一条不会出错的路径继续执行，或者不得不结束程序，但在结束前可以做一些必要的工作，例如将内存中的数据写入文件、关闭打开的文件、释放分配的内存等。
C++ 异常处理机制会涉及 try、catch、throw 三个关键字。
## 01 C++异常处理入门，C++ try catch入门
程序的错误分为三种，分别是语法错误、逻辑错误和运行时错误。\
- 语法错误在编译和链接阶段就能发现，只有 100% 符合语法规则的代码才能生成可执行程序。语法错误是最容易发现、最容易定位、最容易排除的错误，程序员最不需要担心的就是这种错误。
- 逻辑错误是说我们编写的代码思路有问题，不能够达到最终的目标，这种错误可以通过调试来解决。
- 运行时错误是指程序在运行期间发生的错误，例如除数为 0、内存分配失败、数组越界、文件不存在等。C++ 异常（Exception）机制就是为解决运行时错误而引入。

我们可以借助C++异常机制来捕获异常，避免程序崩溃，常用语法：
```
try{
    //可能抛出异常的语句
}catch(exceptionType variable){
    //处理异常的语句
}
```
catch 关键字后面的exceptionType variable指明了当前 catch 可以处理的异常类型，以及具体的出错信息。

*异常的处理流程:*  
抛出（Throw）--> 检测（Try） --> 捕获（Catch）

发生异常的位置:异常可以发生在当前的 try 块中，也可以发生在 try 块所调用的某个函数中，或者是所调用的函数又调用了另外的一个函数，这个另外的函数中发生了异常。这些异常，都可以被 try 检测到。
throw关键字用来抛出一个异常，这个异常会被 try 检测到，进而被 catch 捕获。关于 throw 的用法，我们将在下节深入讲解，这里大家只需要知道，在 try 块中直接抛出的异常会被 try 检测到。
## 02 C++异常类型以及多级catch匹配
遗留下一个问题，就是 catch 关键字后边的exceptionType variable.
exceptionType是异常类型，它指明了当前的 catch 可以处理什么类型的异常；variable是一个变量，用来接收异常信息。当程序抛出异常时，会创建一份数据，这份数据包含了错误信息，程序员可以根据这些信息来判断到底出了什么问题，接下来怎么处理。

异常既然是一份数据，那么就应该有数据类型。C++ 规定，异常类型可以是 int、char、float、bool 等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型。C++ 语言本身以及标准库中的函数抛出的异常，都是 exception 类或其子类的异常。也就是说，抛出异常时，会创建一个 exception 类或其子类的对象。
exceptionType variable和函数的形参非常类似，当异常发生后，会将异常数据传递给 variable 这个变量，这和函数传参的过程类似。当然，只有跟 exceptionType 类型匹配的异常数据才会被传递给 variable，否则 catch 不会接收这份异常数据，也不会执行 catch 块中的语句。换句话说，catch 不会处理当前的异常。
我们可以将 catch 看做一个没有返回值的函数，当异常发生后 catch 会被调用，并且会接收实参（异常数据）。
但是 catch 和真正的函数调用又有区别：
真正的函数调用，形参和实参的类型必须要匹配，或者可以自动转换，否则在编译阶段就报错了。
而对于 catch，异常是在运行阶段产生的，它可以是任何类型，没法提前预测，所以不能在编译阶段判断类型是否正确，只能等到程序运行后，真的抛出异常了，再将异常类型和 catch 能处理的类型进行匹配，匹配成功的话就“调用”当前的 catch，否则就忽略当前的 catch。
另外需要注意的是，如果不希望 catch 处理异常数据，也可以将 variable 省略掉，也即写作：

```
try{
    // 可能抛出异常的语句
}catch(exceptionType){
    // 处理异常的语句
}
```
这样只会将异常类型和 catch 所能处理的类型进行匹配，不会传递异常数据了。

### 多级 catch

一个 try 后面可以跟多个 catch：
```
try{
    //可能抛出异常的语句
}catch (exception_type_1 e){
    //处理异常的语句
}catch (exception_type_2 e){
    //处理异常的语句
}
//其他的catch
catch (exception_type_n e){
    //处理异常的语句
}
```
当异常发生时，程序会按照从上到下的顺序，将异常类型和 catch 所能接收的类型逐个匹配。一旦找到类型匹配的 catch 就停止检索，并将异常交给当前的 catch 处理（其他的 catch 不会被执行）。如果最终也没有找到匹配的 catch，就只能交给系统处理，终止程序的运行。
本例中，我们定义了一个基类 Base，又从 Base 派生类出了 Derived。抛出异常时，我们创建了一个 Derived 类的匿名对象，也就是说，异常的类型是 Derived。
我们期望的是，异常被catch(Derived)捕获，但是从输出结果可以看出，异常提前被catch(Base)捕获了，这说明 catch 在匹配异常类型时发生了向上转型（Upcasting）。

### catch 在匹配过程中的类型转换

C/C++ 中存在多种多样的类型转换，以普通函数（非模板函数）为例，发生函数调用时，如果实参和形参的类型不是严格匹配，那么会将实参的类型进行适当的转换，以适应形参的类型，这些转换包括：
算数转换：例如 int 转换为 float，char 转换为 int，double 转换为 int 等。
向上转型：也就是派生类向基类的转换，请猛击《C++向上转型（将派生类赋值给基类）》了解详情。
const 转换：也即将非 const 类型转换为 const 类型，例如将 char * 转换为 const char *。
数组或函数指针转换：如果函数形参不是引用类型，那么数组名会转换为数组指针，函数名也会转换为函数指针。
用户自定的类型转换。

catch 在匹配异常类型的过程中，也会进行类型转换，但是这种转换受到了更多的限制，仅能进行「向上转型」、「const 转换」和「数组或函数指针转换」，其他的都不能应用于 catch。

向上转型在上面的例子中已经发生了，下面的例子演示了 const 转换以及数组和指针的转换：

```
#include <iostream>
using namespace std;
int main(){
    int nums[] = {1, 2, 3};
    try{
        throw nums;
        cout<<"This statement will not be executed."<<endl;
    }catch(const int *){
        cout<<"Exception type: const int *"<<endl;
    }
    return 0;
}
```
上述先数组转换指针，然后const转换。
nums 本来的类型是int[3]，但是 catch 中没有严格匹配的类型，所以先转换为int *，再转换为const int *。

## 03 C++ throw（抛出异常）详解
在《C++异常处理》一节中，我们讲到了 C++ 异常处理的流程，具体为：
抛出（Throw）--> 检测（Try） --> 捕获（Catch）

异常必须显式地抛出，才能被检测和捕获到；如果没有显式的抛出，即使有异常也检测不到。
在 C++ 中，我们使用 throw 关键字来显式地抛出异常，它的用法为：
throw exceptionData;

exceptionData 是“异常数据”的意思，它可以包含任意的信息，完全有程序员决定。exceptionData 可以是 int、float、bool 等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型.

## 04 C++ exception类：C++标准异常的基类
C++语言本身或者标准库抛出的异常都是 exception 的子类，称为标准异常（Standard Exception）。你可以通过下面的语句来捕获所有的标准异常：